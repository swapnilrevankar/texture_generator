using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using BNB;

public class GenerateTexture : MonoBehaviour
{
    public GameObject banubaFaceGameobject;
    public GameObject savedFaceGameobject;

    public float scaleOffset; 
    private void Update() 
        {
            if (Input.GetKeyUp(KeyCode.L))
        {
            CreateBanubaMeshCopy(banubaFaceGameobject);
            CreateSavedMeshCopy(savedFaceGameobject, scaleOffset);
        }
        }

    private static void CreateSavedMeshCopy(GameObject gameObject, float scaleOffset)
    {
        /*=========================================================================

            Mesh H
            Creates a copy of Saved static mesh generated by Banuba and normalizes the mesh

        =========================================================================*/

        GameObject cloneGameobject = Instantiate(gameObject);
        NormalizeSize(cloneGameobject);
        Vector3 scaleChange = new Vector3(scaleOffset, scaleOffset, scaleOffset);
        cloneGameobject.transform.localScale += scaleChange;
    }
    private static void CreateBanubaMeshCopy(GameObject gameObject)
    {
        /*=========================================================================

            Mesh H
            Creates a copy of face mesh generated by Banuba and normalizes the mesh

        =========================================================================*/

        // Banuba components
        MeshRenderer banubaMeshrenderer = gameObject.GetComponent<MeshRenderer>();
        Material banubaMaterial = banubaMeshrenderer.material;
        Texture banubaTexture = banubaMaterial.mainTexture;

        // Clone mesh 
        GameObject cloneGameobject = Instantiate(gameObject);
        MeshFilter cloneMeshFilter = cloneGameobject.GetComponent<MeshFilter>();
        cloneMeshFilter.mesh = cloneMeshFilter.mesh;

        // Disable Banuba scripts 
        FaceMeshController cloneFaceMeshControllerScript = cloneGameobject.GetComponent<FaceMeshController>();
        cloneFaceMeshControllerScript.enabled = false;

        // Duplicate Banuba texture
        Texture cloneTexture = new Texture2D(banubaTexture.width, banubaTexture.height, TextureFormat.ARGB32, false);
        Graphics.CopyTexture(banubaTexture, cloneTexture);

        // Duplicate material
        Material cloneMaterial = Instantiate(banubaMaterial);
        cloneMaterial.SetTexture("_MainTex", cloneTexture);

        // Set material matrix like in Banuba
        cloneMaterial.SetMatrix("_TextureMVP",banubaMaterial.GetMatrix("_TextureMVP"));
        cloneMaterial.SetInt("_TextureRotate",banubaMaterial.GetInt("_TextureRotate"));
        cloneMaterial.SetInt("_TextureYFlip",banubaMaterial.GetInt("_TextureYFlip"));

        // Assing material to cloned mesh
        MeshRenderer cloneMeshRenderer = cloneGameobject.GetComponent<MeshRenderer>();
        cloneMeshRenderer.material = cloneMaterial;

        // Add mesh collider 
        MeshCollider meshCollider = cloneGameobject.AddComponent<MeshCollider>();

        // Normalize mesh 
        NormalizeSize(cloneGameobject);
    }

    private static T[] GetAll<T>(GameObject root, bool includeInactiveChildren = false, bool exclude = true) where T : Component
        {
            if (!root)
            {
                return null;
            }

            if (exclude)
            {

                List<T> rends = new List<T>();
                foreach (T component in root.GetComponentsInChildren<T>(includeInactiveChildren))
                {
                    if (component.GetComponent<ExcludeFromBake>() == null)
                    {
                        rends.Add(component);
                    }
                }

                return rends.ToArray();
            }

            return root.GetComponentsInChildren<T>();
        }
    private static Bounds ComputeBounds(GameObject root)
        {
            Quaternion currentRotation = root.transform.rotation;
            root.transform.rotation = Quaternion.Euler(0f, 0f, 0f);

            Bounds bounds = new Bounds(root.transform.position, Vector3.zero);

            Renderer[] rends = GetAll<Renderer>(root);
            foreach (Renderer renderer in rends)
            {
                bounds.Encapsulate(renderer.bounds);
            }

            Vector3 localCenter = bounds.center - root.transform.position;
            bounds.center = localCenter;
            root.transform.rotation = currentRotation;

            return bounds;
        }
    private static void NormalizeSize(GameObject obj)
        {
            Transform t = obj.transform;
            t.localScale = Vector3.one;
            Bounds bounds = ComputeBounds(obj);
            Vector3 size = bounds.size;
            float scale = 1 / Mathf.Max(size.x, Mathf.Max(size.y, size.z));
            t.localScale *= scale;
        }
}
